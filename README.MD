### Lab1 
```
Zaimplementuj algorytm, który jako dane wejściowe otrzymuje wierzchołki wielokąta prostego oraz sprawdza, 
trawersując od pierwszego przeciwnie do ruchu wskazówek zegara, czy istnieje jądro (3 pkt.).
Jeżeli tak powinien obliczyć obwód (1,5 pkt.) oraz pole (0,5 pkt.) wyznaczonego jądra.
```

### Lab2 

```
Zaimplementuj algorytm rozwiązujący problem pary najbliższych punktów na płaszczyźnie wykorzystując technikę "dziel i zwyciężaj". 
Implementacja powinna mieć złożoność czasową rzędu O(nlog n), gdzie n jest liczbą poziomych punktów otrzymanych na wejściu.

```

### Lab3

```
Zaimplementuj algorytm, który jako dane wejściowe otrzymuje n-elementowy zbiór 2-wymiarowych punktów oraz prostokątny przedział. 
Na podstawie otrzymanego zbioru punktów powinno zostać zbudowane odpowiednie KD-drzewo w czasie O(nlog n) i pamięci rzędu O(n) (3 pkt.). 
Następnie przy pomocy utworzonego KD-drzewa powinien rozwiązać problem znajdywania punktów w obszarze prostokątnym w czasie O(√n + k), gdzie k jest liczbą wyznaczonych punktów (2 pkt.).
```

### Lab 4

```
Zaimplementuj dwa algorytmy (największa możliwa wartość plecaka, najmniejszy rozmiar plecaka) rozwiązujące problem plecakowy wykorzystując programowanie dynamiczne (3,5 pkt.). 
Implementacja pierwszego sposobu (największa możliwa wartość plecaka) musi mieć złożoność czasową rzędu O(nS),
a drugiego sposobu (najmniejszy rozmiar plecaka) O(nV), gdzie n jest liczbą przedmiotów, 
S największą pojemnością plecaka i V sumą wartości wszystkich przedmiotów. Przetestuj eksperymentalnie ich złożoność obliczeniową (wykonaj pomiar czasu działania zaimplementowanych algorytmu) (0,5 pkt.).
```
